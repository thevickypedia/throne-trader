from datetime import datetime, timedelta
from typing import Dict

import pandas
import webull
import yfinance


def classify(stock_data: pandas.DataFrame, short_window: int, long_window: int) -> Dict[str, str]:
    """Calculates short term moving average, long term moving average to generate the signals."""
    # Calculate short-term (e.g., 20-day) and long-term (e.g., 50-day) moving averages
    stock_data['SMA_short'] = stock_data['close'].rolling(window=short_window).mean()
    stock_data['SMA_long'] = stock_data['close'].rolling(window=long_window).mean()

    # Generate the buy, sell, and hold signals
    stock_data['buy'] = stock_data['SMA_short'] > stock_data['SMA_long']
    stock_data['sell'] = stock_data['SMA_short'] < stock_data['SMA_long']
    stock_data['hold'] = ~(stock_data['buy'] | stock_data['sell'])

    # Filter buy, sell, and hold signals
    buy_signals = stock_data[stock_data['buy']]
    sell_signals = stock_data[stock_data['sell']]
    hold_signals = stock_data[stock_data['hold']]

    buy_signals_timestamped = {
        pandas.Timestamp(timestamp).to_pydatetime(): "Buy"
        for timestamp in buy_signals.index.values
    }
    sell_signals_timestamped = {
        pandas.Timestamp(timestamp).to_pydatetime(): "Sell"
        for timestamp in sell_signals.index.values
    }
    hold_signals_timestamped = {
        pandas.Timestamp(timestamp).to_pydatetime(): "Hold"
        for timestamp in hold_signals.index.values
    }

    all_signals = dict(sorted(
        {**buy_signals_timestamped, **sell_signals_timestamped, **hold_signals_timestamped}.items(),
        key=lambda x: x[0].timestamp()
    ))

    all_signals_ct = len(all_signals)
    assert all_signals_ct == len(stock_data), "Not all data was accounted for stock signals."

    assessment = {
        "Buy": round(len(buy_signals) / all_signals_ct * 100, 2),
        "Sell": round(len(sell_signals) / all_signals_ct * 100, 2),
        "Hold": round(len(hold_signals) / all_signals_ct * 100, 2)
    }
    for key, value in assessment.items():
        print(f"{key} Signals:", f"{value}%")

    print(f"\nAlgorithm's assessment: {max(assessment, key=assessment.get).upper()}\n")

    return {
        k.strftime("%A - %Y-%m-%d"): v
        for k, v in all_signals.items()
    }


def moving_average_breakout_strategy(symbol: str,
                                     short_window: int = 20,
                                     long_window: int = 50,
                                     bar_count: int = 100) -> Dict[str, str]:
    """Get buy, sell and hold signals for a particular stock using breakout strategy.

    Args:
        symbol: Stock ticker.
        short_window: Short term moving average.
        long_window: Long term moving average.
        bar_count: Number of bars from webull.

    See Also:
        - A larger `bar_count` gives longer historical data for trend analysis.
        - A smaller count focuses on recent data for short-term signals.
        - Experiment and backtest to find the best fit for your approach.

    Returns:
        Dict[str, str]:
        A dictionary of each day's buy, sell and hold signals.
    """
    # Fetch historical stock data using the 'get_bars' method from the 'webull' package
    bars = webull.paper_webull().get_bars(stock=symbol, interval='d', count=bar_count)

    # Create a DataFrame from the fetched data
    stock_data = pandas.DataFrame(bars)
    return classify(stock_data, short_window, long_window)


def moving_average_crossover_strategy(symbol: str,
                                      short_window: int = 20,
                                      long_window: int = 50,
                                      years: int = 1) -> Dict[str, str]:
    """Get buy, sell and hold signals for a particular stock using breakout strategy.

    Args:
        symbol: Stock ticker.
        short_window: Short term moving average.
        long_window: Long term moving average.
        years: Number of years for the historical data.

    See Also:
        - | The number of years used to calculate moving averages impacts the frequency, responsiveness,
          | accuracy, and risk associated with the signals generated by the strategy.
        - A larger number of years will provide a longer historical perspective and result in smoother moving averages.
        - This tends to generate fewer buy and sell signals as the strategy focuses on longer-term trends.
        - Experiment and backtest to find the best fit for your approach.

    Returns:
        Dict[str, str]:
        A dictionary of each day's buy, sell and hold signals.
    """
    # Fetch historical stock data using yfinance
    start = (datetime.now() - timedelta(days=years * 365)).strftime("%Y-%m-%d")
    end = datetime.now().strftime("%Y-%m-%d")
    stock_data = yfinance.download(symbol, start=start, end=end)
    return classify(stock_data, short_window, long_window)
