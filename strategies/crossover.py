import os
import sys
from datetime import datetime, timedelta
from typing import Dict

from helper import squire


def get_crossover_signals(symbol: str,
                          short_window: int = 20,
                          long_window: int = 50,
                          years: int = 1,
                          simple: bool = False) -> Dict[str, str]:
    """Get buy, sell and hold signals for a particular stock using breakout strategy.

    Args:
        symbol: Stock ticker.
        short_window: Short term moving average.
        long_window: Long term moving average.
        years: Number of years for the historical data.
        simple: Simply returns whether it's a buy, sell or hold.

    See Also:
        - | The number of years used to calculate moving averages impacts the frequency, responsiveness,
          | accuracy, and risk associated with the signals generated by the strategy.
        - A larger number of years will provide a longer historical perspective and result in smoother moving averages.
        - This tends to generate fewer buy and sell signals as the strategy focuses on longer-term trends.
        - Experiment and backtest to find the best fit for your approach.

    Returns:
        Dict[str, str]:
        A dictionary of each day's buy, sell and hold signals.
    """
    # Fetch historical stock data
    stock_data = squire.get_historical_data(symbol=symbol, years=years, df=True)

    # Calculate short-term (e.g., 20-day) and long-term (e.g., 50-day) moving averages
    stock_data['SMA_short'] = stock_data['Close'].rolling(window=short_window).mean()
    stock_data['SMA_long'] = stock_data['Close'].rolling(window=long_window).mean()

    # Generate the buy, sell, and hold signals
    stock_data['buy'] = stock_data['SMA_short'] > stock_data['SMA_long']
    stock_data['sell'] = stock_data['SMA_short'] < stock_data['SMA_long']
    stock_data['hold'] = ~(stock_data['buy'] | stock_data['sell'])

    return squire.classify(stock_data, simple)
